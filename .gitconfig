[core]
    autocrlf = input
    safecrlf = warn
    editor = vim # or nano (if you prefer)
[color]
    ui = true
[color "branch"]
    current = yellow reverse
    local = yellow
    remote = green
[color "diff"]
    meta = yellow bold
    frag = magenta bold
    old = red bold
    new = green bold
[alias]
    # show aliases
    la = !git config --list | grep 'alias\\.' | sed 's/alias\\.\\([^=]*\\)=\\(.*\\)/\\1\\\t = \\2/' 

    # add
    a  = add                          # stage     modified         created
    au = add --update .               # stage all modified deleted        
    aa = add --all    .               # stage all modified deleted created

    ai = add -i                       # stage interactive

    ap = add --patch                  # stage commits chunk by chunk
    chunkyadd = add --patch           # stage commits chunk by chunk

    # branch
    b = branch --color=always -vv     # branch alias to add color and verbosity
    ba = branch -a --color=always -vv # show all branches

    # commit
    c = commit                        # commit
    cm = commit -m                    # commit with message
    amend = commit --amend            # amend last commit (to fix commit message: git commit --amend -m "fixed msg")

    # checkout
    co = checkout                     # checkout
    cb = checkout -b                  # create and switch to a new branch

    # cherry-pick
    cp = cherry-pick -x               # grab a change from a branch

    # diff
    d     = diff --word-diff=color                   # unstaged changes

    dc    = diff --word-diff=color --cached          # staged changes
    dcu   = diff --word-diff=color --cached -U1000   # staged changes, with context

    dh    = diff --word-diff=color HEAD              # changes between last commit and (both staged and unstaged changes)
    dhu   = diff --word-dfff=color HEAD  -U1000      # changes between last commit and (both staged and unstaged changes), with context

    last  = diff --word-diff=color HEAD^             # changes between second-last commit and (both staged and unstaged changes)
    lastu = diff --word-diff=color HEAD^ -U1000      # changes between second-last commit and (both staged and unstaged changes), with context

    # fetch
    f = fetch                         # update local copy of remote repository

    # grep
    grep = grep --break --show-function --function-context

    # log
    l   = log --graph --abbrev-commit --decorate --all                      --format=format:'%C(bold dim magenta)%h %C(reset)%C(bold blue)%aD %C(reset)%C(green)(%ar)%C(reset)%C(bold red)%d %n''        %C(reset)%C(white)%s %C(reset)%C(dim yellow)<%aN>%C(reset)'
    ll  = log --stat  --abbrev-commit --decorate --all                      --format=format:'%C(bold dim magenta)%h %C(reset)%C(bold blue)%aD %C(reset)%C(green)(%ar)%C(reset)%C(bold red)%d %n''        %C(reset)%C(white)%s %C(reset)%C(dim yellow)<%aN>%C(reset)'
    lll = log --graph --abbrev-commit --decorate --all -p --word-diff=color --format=format:'%C(bold dim magenta)%h %C(reset)%C(bold blue)%aD %C(reset)%C(green)(%ar)%C(reset)%C(bold red)%d %n''        %C(reset)%C(white)%s %C(reset)%C(dim yellow)<%aN>%C(reset)'
    # git log --grep="something appearing in a commit message"

    # merge
    merge = merge --no-ff

    # ls-files
    ls = ls-files . --exclude-standard
    
    pod = push origin --delete        # delete remote branch <BRANCHNAME>

    # rebase
    rc = rebase --continue            # continue rebase
    rs = rebase --skip                # skip rebase

    # remote
    r = remote -v                     # show remotes (verbose)
    origininfo = remote show origin   # show info about origin

    # refs
    refs = show-ref                   # show refs
    reflog = reflog                   # show log of changes to refs

    # reset
    unstage     = reset HEAD          # unstage files
    chunkyreset = reset --patch HEAD  # unstage file hunks selectively
    uncommit    = reset --soft  HEAD^ # go back before last commit, with files in uncommitted state
    undocommit  = reset --soft  HEAD^ # go back before last commit, with files in uncommitted state

    filelog = log -u                  # show changes to a file
    mt = mergetool                    # fire up the merge tool

    sha1 = ls-tree master             # shows hashes of files in current folder

    show = show --word-diff=color     # shows the lines in a commit (instead of using git diff HEAD~3 HEAD~2

    # stash
    ss = stash save                   # stash changes with name (save changes and add to stack)
    sl = stash list                   # list stashes
    sp = stash pop                    # apply stash (restore changes and pop from stack)
    sa = stash apply                  # apply stash (restore changes without popping from stack)
    sd = stash drop                   # drop stashes (destory changes)

    ssh0 = stash show -p --stat --word-diff=color stash@{0}
    ssh1 = stash show -p --stat --word-diff=color stash@{1}
    ssh2 = stash show -p --stat --word-diff=color stash@{2}
    ssh3 = stash show -p --stat --word-diff=color stash@{3}
    ssh4 = stash show -p --stat --word-diff=color stash@{4}
    ssh5 = stash show -p --stat --word-diff=color stash@{5}

    # status
    s = status                        # status
    st = status                       # status
    stat = status                     # status

    # tag
    t = tag -n                        # show tags with <n> lines of each tag message

    # svn helpers
    svnr = svn rebase
    svnd = svn dcommit
    svnl = svn log --oneline --show-commit

    # maintenance
    count-objects = count-objects -v
    gc = gc
    fsck = fsck --full
[apply]
    whitespace = nowarn
[branch]
    autosetupmerge = true
[diff]
    mnemonicprefix = true
[grep]
    linenumber = true
    patterntype = perl
[merge]
    summary = true
    verbosity = 1
    conflictstyle = diff3
[mergetool]
    prompt = false
[push]
    default = simple
